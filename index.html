<!DOCTYPE html>
<html>
<head>
    <title>Tahtien Tappaja</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: black;
            font-family: Arial, sans-serif;
            
        }
        #gameCanvas {
            border: 2px solid #333;
			touch-action: none;
        }
        .screen {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			background: rgba(16, 22, 78, 0.4); /* Make background semi-transparent */
			padding: 20px;
			color: white;
			text-align: center;
			z-index: 100;
			display: none;
		}
		#logoContainer {
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			width: 100%;
		}

		#startScreen {
			z-index: 90; // Lower than loading screen
		}

		#loadingScreen {
			z-index: 95; // Higher than start screen
		}
        .button {
            background: #4CAF50;
            border: none;
            padding: 15px 30px;
            color: white;
            cursor: pointer;
            font-size: 18px;
        }
        #gameStats {
			position: fixed;
			top: 10px;
			left: 10px;
			color: white;
			z-index: 100;
			display: none;
			width: 100%;
			text-align: center;
			padding: 5px;
		}
        #gameOverScreen {
            display: none;
            z-index: 200;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
	<div id="gameStats" style="display:none; visibility:hidden; opacity:0; position:absolute; left:-9999px;">
		<div>Score: <span id="score">0</span></div>
		<div>HP: <span id="hp">100</span></div>
	</div>

	<div id="startScreen" class="screen">
		<div id="logoContainer">
			<img src="LOGO.png" alt="Logo" style="max-width: 300px; margin-bottom: 20px; display: block; margin-left: auto; margin-right: auto;">
			<canvas id="characterAnimCanvas" width="250" height="250" style="margin-bottom: 20px; display: block; margin-left: auto; margin-right: auto;"></canvas>
		</div>
		<button id="startButton" class="button">TESTI7</button>
	</div>

	<div id="gameOverScreen" class="screen" style="display:none;">
		<h2>Game Over</h2>
		<p>Final Score: <span id="finalScore">0</span></p>
		<button id="restartButton" class="button">Restart Game</button>
	</div>
    <script>
// Asset loading handler
// Modify your assetLoaded function to handle the transition better
function assetLoaded() {
    assetsLoaded++;
    console.log("Asset loaded. Total: " + assetsLoaded + "/" + totalAssets);
    
    // If all assets are loaded, switch to start screen
    if (assetsLoaded >= totalAssets) {
        console.log("All assets loaded, switching to start screen");
        
        // Make sure we stop the loading animation
        if (loadingLoop) {
            cancelAnimationFrame(loadingLoop);
            loadingLoop = null;
        }
        
        // Final clear of the canvas to remove loading screen
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        setTimeout(() => {
            switchScreen("start");
        }, 500);
    }
}
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
		const startScreen = document.getElementById('startScreen');
		const gameOverScreen = document.getElementById('gameOverScreen');
		const gameStats = document.getElementById('gameStats');
		const startButton = document.getElementById('startButton');
		const restartButton = document.getElementById('restartButton');
		const scoreElement = document.getElementById('score');
		const hpElement = document.getElementById('hp');
		const finalScoreElement = document.getElementById('finalScore');
		





		
		canvas.width = 400;
        canvas.height = 800;
		
		function resizeCanvas() {
			// Get the dimensions of the viewport
			const viewportWidth = window.innerWidth;
			const viewportHeight = window.innerHeight;
			
			// Set canvas size to fit screen while maintaining aspect ratio
			if (viewportWidth / viewportHeight > 1) {
				// Landscape orientation
				canvas.height = Math.min(viewportHeight * 0.95, 800);
				canvas.width = canvas.height / 2; // Maintain your 1:2 aspect ratio
			} else {
				// Portrait orientation (most phones)
				canvas.width = Math.min(viewportWidth * 0.95, 400);
				canvas.height = canvas.width * 2; // Maintain your 1:2 aspect ratio
			}
			
			// Recreate mobile controls with new canvas dimensions
			if (isMobile) {
				createMobileControls();
			}
		}
		
        // Game state global variables
		let currentScreen = "loading";
		let loadingLoop;
		let totalAssets = 10; // Increased by 1 to include the logo
		let keys = {}; // Track pressed keys
		let isMobile = false; // Will be set based on device detection
		let joystick = {
			active: false,
			baseX: 0,
			baseY: 0,
			knobX: 0,
			knobY: 0,
			radius: 50,  // Size of the joystick base
			knobRadius: 25, // Size of the inner knob
			maxDistance: 50 // Maximum distance the knob can move from center
		};

		let fireButton = {
			x: 0,
			y: 0,
			radius: 40,
			pressed: false
		};
		let gameStartSequence = false;
		let playerReady = false;
		let enemySpawningActive = false;
		let playerInvulnerable = false;
		let playerInvulnerableTimer = 0;
		let assetsLoaded = 0;
		let isLoading = true;
		let backgroundMusic = null;
		let isBackgroundMusicPlaying = false;
		// Main screen stars
		const mainScreenStars = [];
		const NUM_MAIN_SCREEN_STARS = 50;
		let mainScreenStarsAnimationId = null;
		let mainCharacterAnimFrame = 0;
		let mainCharacterAnimTimer = 0;
		const mainCharacterFrameCount = 4; // Your animation has 4 frames
		const mainCharacterFrameWidth = 250; // Width of each frame in pixels
		const mainCharacterFrameHeight = 1000; // Height of each frame in pixels
		const mainCharacterFrameDuration = 150; // Milliseconds per frame (adjust for speed)
		let powerupActive = false;
		let powerupBulletsLeft = 0;
		let powerup = null;
		const powerupMilestones = [100, 500, 1000, 3000];
		let reachedMilestones = [false, false, false, false];
		let powerupSpawned = false;
        let gameLoop;
        let isGameRunning = false;
        let lastShot = 0;
        let score = 0;
        const shootingDelay = 250;
		let rapidFireShootingDelay = shootingDelay / 3; //200% faster
		let gameTime = 0; // Time in seconds
		let lastTimeCheck = 0;
		let explosionAnimation = null;
		let bossSpawned = false;
		let regularEnemiesDisabled = false;
		let boss = null;
		let bossAnimationFrame = 0;
		let bossAnimationTimer = 0;
		const bossFrameCount = 6; // Your Piskel has 6 frames
		const bossFrameWidth = 250; // Width of each frame in pixels
		const bossFrameHeight = 250; // Height of each frame in pixels
		const bossFrameDuration = 100; // Milliseconds per frame (adjust for speed)
		let lastBossMissile = 0;
		const bossMissileDelay = 5000; // 10 seconds
		window.pendingScreenTimeouts = [];
// Add this function to properly initialize loading
function startLoading() {
    console.log("Initializing loading process");
    // Switch to loading screen explicitly
    currentScreen = "loading";
    isLoading = true;
    isGameRunning = false;
    
    // Hide all UI screens during loading
    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('gameOverScreen').style.display = 'none';
    document.getElementById('gameStats').style.display = 'none';
    
    // Reset asset loading counter
    assetsLoaded = 0;
    
    // Start loading animation
    console.log("Starting loading animation");
    function loadingAnimation() {
        if (currentScreen === "loading") {
            showLoadingScreen();
            loadingLoop = requestAnimationFrame(loadingAnimation);
        }
    }
    loadingLoop = requestAnimationFrame(loadingAnimation);
    
    // Start loading assets
    console.log("Starting asset loading");
    loadAllAssets();
}
function switchScreen(newScreen) {
    console.log(`Switching from ${currentScreen} to ${newScreen}`);
	// Cancel star animation if switching away from start screen
    if (currentScreen === "start" && newScreen !== "start" && mainScreenStarsAnimationId) {
        cancelAnimationFrame(mainScreenStarsAnimationId);
        mainScreenStarsAnimationId = null;
    }
    
    // Cancel any loading animation
    if (loadingLoop) {
        cancelAnimationFrame(loadingLoop);
        loadingLoop = null;
    }
    
    // Hide all screens
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const gameStats = document.getElementById('gameStats');
    
    if (startScreen) startScreen.style.display = 'none';
    if (gameOverScreen) gameOverScreen.style.display = 'none';
    if (gameStats) gameStats.style.display = 'none';
    
    // Show appropriate screen
    if (newScreen === "loading") {
        isLoading = true;
        isGameRunning = false;
        
        // Start loading animation
        loadingLoop = requestAnimationFrame(function loadingAnimation() {
            showLoadingScreen();
            loadingLoop = requestAnimationFrame(loadingAnimation);
        });
    } 
    else if (newScreen === "start") {
		isLoading = false;
		isGameRunning = false;
		
		// Draw background with stars first
		ctx.fillStyle = '#10164e';
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		
		// Initialize stars before showing the UI
		initializeMainScreenStars();
		mainScreenStarsAnimationId = requestAnimationFrame(updateAndDrawMainScreenStars);
		
		// Then show the UI
		if (startScreen) {
			startScreen.style.display = 'block';
		}
		
		// Start main character animation
		mainCharacterAnimFrame = 0;
		mainCharacterAnimTimer = Date.now();
		requestAnimationFrame(animateMainCharacter);
	} 
    else if (newScreen === "game") {
        isLoading = false;
        isGameRunning = true;
        
        if (gameStats) {
            gameStats.style.display = 'block';
        }
    } 
    else if (newScreen === "gameOver") {
        isLoading = false;
        isGameRunning = false;
        
        if (gameOverScreen) {
            gameOverScreen.style.display = 'block';
        }
    }
    
    currentScreen = newScreen;
}

function detectMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
           (window.matchMedia && window.matchMedia("(max-width: 768px)").matches);
}
function createMobileControls() {
    // Position the joystick in the bottom left using relative positioning
    joystick.baseX = canvas.width * 0.20; // 20% from left edge
    joystick.baseY = canvas.height * 0.85; // 85% from top (15% from bottom)
    joystick.knobX = joystick.baseX;
    joystick.knobY = joystick.baseY;
    
    // Scale joystick size based on canvas dimensions
    const minDimension = Math.min(canvas.width, canvas.height * 0.3);
    joystick.radius = minDimension * 0.15; // 15% of the smaller dimension
    joystick.knobRadius = joystick.radius * 0.5; // Proportional to base
    joystick.maxDistance = joystick.radius * 1.2; // Slightly larger than radius
    
    // Position the fire button in the bottom right
    fireButton.x = canvas.width * 0.80; // 80% from left edge
    fireButton.y = canvas.height * 0.85; // 85% from top
    fireButton.radius = joystick.radius; // Same size as joystick for consistency
}

// Fix the loadAllAssets function to use window.enemyImage references:
// Replace your loadAllAssets function with this improved version:
function loadAllAssets() {
    // Reset the counter to make sure we start from 0
    assetsLoaded = 0;
    
    // Create a timeout safety mechanism
    const loadingTimeout = setTimeout(() => {
        console.log("Loading timeout - forcing game to start anyway");
        // Force set the exact count rather than incrementing
        assetsLoaded = totalAssets;
        showLoadingScreen(); // Update the loading screen one last time
        
        // Switch to start screen after a brief delay to show 100%
        setTimeout(() => {
            if (currentScreen === "loading") {
                switchScreen("start");
            }
        }, 500);
    }, 10000);
    
    if (!window.pendingScreenTimeouts) window.pendingScreenTimeouts = [];
	window.pendingScreenTimeouts.push(loadingTimeout);
    
    // Simple load function for each image
    function loadImage(img, src) {
        img.onload = function() { 
            assetLoaded(); 
            this.onload = null; 
        };
        img.onerror = function() { 
            console.error("Failed to load image:", src);
            assetLoaded(); 
            this.onerror = null; 
        };
        img.src = src;
    }
    
    // Load all images
    loadImage(window.enemyImage, 'punatahti.png');
    loadImage(window.shootingEnemyImage, 'sinitahti.png');
    loadImage(window.circularEnemyImage, 'vihertahti.png');
    loadImage(window.spinnerEnemyImage, 'keltatahti.png');
    loadImage(window.powerupImage, 'powerup1.png');
    loadImage(window.bossImage, 'boss.png');
    loadImage(window.playerImage, 'luke.png');
    loadImage(window.logoImage, 'LOGO.png');
	loadImage(window.mainCharacterAnimImage, 'alkuanim.png');
    
    // Audio loading with simplified approach
    try {
        const tempAudio = new Audio();
        tempAudio.addEventListener('canplaythrough', function() {
            assetLoaded();
        }, {once: true});
        
        tempAudio.addEventListener('error', function() {
            console.log("Audio preload error - continuing anyway");
            assetLoaded();
        }, {once: true});
        
        // Shorter timeout for audio
        setTimeout(() => {
            if (assetsLoaded === totalAssets - 1) {
                console.log("Audio timeout - continuing anyway");
                assetLoaded();
            }
        }, 2000);
        
        tempAudio.src = 'tappaja.mp3';
    } catch (e) {
        console.error("Audio preload error:", e);
        assetLoaded(); // Count as loaded even if it fails
    }
	const checkAssetsInterval = setInterval(() => {
		if (assetsLoaded >= totalAssets) {
			console.log("All assets loaded via interval check");
			clearInterval(checkAssetsInterval);
			
			// Switch to start screen after a brief delay
			setTimeout(() => {
				if (currentScreen === "loading") {
					isLoading = false;
					switchScreen("start");
				}
			}, 500);
		}
	}, 500);
}

// Add this at the end of your script block
document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM loaded, initializing game...");
    
    // Initialize image objects
    window.enemyImage = new Image();
    window.shootingEnemyImage = new Image();
    window.circularEnemyImage = new Image();
    window.spinnerEnemyImage = new Image();
    window.powerupImage = new Image();
    window.bossImage = new Image();
    window.playerImage = new Image();
    window.logoImage = new Image();
	window.mainCharacterAnimImage = new Image();
    
    // Resize canvas to fit the device screen
    resizeCanvas();
    
    // Get references to DOM elements
    const startButton = document.getElementById('startButton');
    const restartButton = document.getElementById('restartButton');
    
    // Fix start button event listener
    if (startButton) {
        startButton.removeEventListener('click', startGame);
        startButton.addEventListener('click', startGame);
        console.log("Start button listener added");
    } else {
        console.error("Start button not found!");
    }
    
    // Restart button
    if (restartButton) {
        restartButton.addEventListener('click', restartGame);
    }
    
    // Add window resize listener
    window.addEventListener('resize', function() {
        resizeCanvas();
    });
    
    // Start the loading process
    setTimeout(startLoading, 100);
});
document.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    
    // Prevent scrolling with arrow keys and space
    if(['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
        e.preventDefault();
    }
});

document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
});


        let lastGroupSpawn = 0;
        const groupSpawnDelay = 15000; // Spawn group every 15 seconds
        // Player
        const player = {
            x: canvas.width / 2,
            y: canvas.height - 80,
            size: 50,
            hp: 100,
            maxHp: 100,
            bullets: []
        };
        // Game objects
        const enemies = [];
        const enemyBullets = [];
        let circularGroup = null;
        // Background stars
        const stars = [];
        const NUM_STARS = 100;
        // Initialize stars with different sizes and speeds
        for (let i = 0; i < NUM_STARS; i++) {
			stars.push({
				x: Math.random() * canvas.width,
				y: Math.random() * canvas.height,
				size: Math.random() * 2 + 0.5, // Stars of different sizes (0.5 to 2.5)
				speed: Math.random() * 0.3 + 0.1, // Very slow speeds (0.1 to 0.4)
				angle: Math.random() * Math.PI * 2, // Random starting rotation
				rotationSpeed: 0.01 + (Math.random() * 0.01) // Small positive rotation speed
			});
		}

function showLoadingScreen() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw loading text
    ctx.fillStyle = 'white';
    ctx.font = '24px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('TESTI7', canvas.width / 2, canvas.height / 2 - 50);
    
    // Draw loading bar background
    ctx.fillStyle = '#333';
    const barWidth = 200;
    const barHeight = 20;
    ctx.fillRect(canvas.width / 2 - barWidth / 2, canvas.height / 2, barWidth, barHeight);
    
    // Draw loading bar progress capped at 100%
    const progress = Math.min(assetsLoaded / totalAssets, 1);
    ctx.fillStyle = '#4CAF50';
    ctx.fillRect(canvas.width / 2 - barWidth / 2, canvas.height / 2, barWidth * progress, barHeight);
    
    // Draw percentage
    ctx.fillStyle = 'white';
    ctx.font = '14px Arial';
    ctx.fillText(`${Math.min(Math.round(progress * 100), 100)}%`, canvas.width / 2, canvas.height / 2 + 40);
}

		// Create a function to initialize and play the music
// Modify the initializeMusic function
function initializeMusic() {
    // If music is already playing, don't initialize again
    if (isBackgroundMusicPlaying) {
        console.log("Music already playing, skipping initialization");
        return;
    }
    
    // For iOS devices
    if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        console.log("iOS device detected, using special audio handling");
        
        // Destroy any existing audio first
        if (backgroundMusic) {
            try {
                backgroundMusic.pause();
                backgroundMusic.src = "";
                backgroundMusic = null;
            } catch (e) {
                console.error("Error cleaning up old audio:", e);
            }
        }
        
        // Create new audio element
        backgroundMusic = new Audio();
        backgroundMusic.src = 'tappaja.mp3';
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0.5;
        
        // Set a flag to prevent multiple play attempts
        let playAttempted = false;
        
        // This function will be called only once
        const playAudioOnce = function() {
            if (playAttempted) return;
            playAttempted = true;
            
            console.log("Attempting to play audio on iOS");
            const playPromise = backgroundMusic.play();
            
            if (playPromise) {
                playPromise.then(() => {
                    console.log("iOS audio playing successfully");
                    isBackgroundMusicPlaying = true;
                }).catch(e => {
                    console.log("iOS audio play error:", e);
                    isBackgroundMusicPlaying = false;
                    playAttempted = false; // Reset to allow another attempt
                });
            }
        };
        
        // iOS requires user interaction to play audio
        playAudioOnce();
        
        // Add a backup play attempt with delay (helps with some iOS versions)
        setTimeout(() => {
            if (!isBackgroundMusicPlaying) {
                console.log("Trying audio play again after delay");
                playAudioOnce();
            }
        }, 1000);
    } 
    // For all other devices
    else {
        if (!backgroundMusic) {
            backgroundMusic = new Audio('tappaja.mp3');
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.5;
            
            backgroundMusic.play().then(() => {
                console.log("Audio playing successfully");
                isBackgroundMusicPlaying = true;
            }).catch(e => {
                console.log("Audio autoplay was prevented:", e);
                // Create a button to allow user to start audio
                const musicButton = document.createElement('button');
                musicButton.innerHTML = "Play Music";
                musicButton.style.position = "absolute";
                musicButton.style.top = "10px";
                musicButton.style.right = "10px";
                musicButton.style.zIndex = "1000";
                musicButton.addEventListener('click', () => {
                    backgroundMusic.play()
                    .then(() => {
                        isBackgroundMusicPlaying = true;
                        musicButton.remove();
                    })
                    .catch(e => console.error("Manual play failed:", e));
                });
                document.body.appendChild(musicButton);
            });
        } else if (backgroundMusic.paused) {
            backgroundMusic.play()
            .then(() => isBackgroundMusicPlaying = true)
            .catch(e => console.log("Could not resume audio:", e));
        }
    }
}

// Additionally, ensure music is stopped when switching away from game
function stopMusic() {
    if (backgroundMusic) {
        try {
            backgroundMusic.pause();
            isBackgroundMusicPlaying = false;
        } catch (e) {
            console.error("Error stopping music:", e);
        }
    }
}

// Add this to handle game state transitions
function endGame() {
    isGameRunning = false;
    cancelAnimationFrame(gameLoop);
    finalScoreElement.textContent = score;
    gameStats.style.display = 'none';
    gameOverScreen.style.display = 'block';
    
    // Stop the music when game ends
    stopMusic();
}




        function updateStars() {
			stars.forEach(star => {
				star.y += star.speed;
				if (star.y > canvas.height) {
					star.y = 0;
					star.x = Math.random() * canvas.width;
				}
			});
		}

		function drawStars() {
			ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
			stars.forEach(star => {
				ctx.beginPath();
				ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
				ctx.fill();
			});
		}
		
        function drawStars() {
			stars.forEach(star => {
				// Save context for rotation
				ctx.save();
				ctx.translate(star.x, star.y);
				ctx.rotate(star.angle);
				
				// Draw a simple plus shape
				ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
				const size = star.size * 2; // Make stars a bit bigger for visibility
				
				// Horizontal line
				ctx.fillRect(-size, -size/4, size*2, size/2);
				
				// Vertical line
				ctx.fillRect(-size/4, -size, size/2, size*2);
				
				ctx.restore();
			});
		}
function initializeMainScreenStars() {
    // Clear existing stars
    mainScreenStars.length = 0;
    
    // Create new stars
    for (let i = 0; i < NUM_MAIN_SCREEN_STARS; i++) {
        mainScreenStars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 2 + 0.5, // Stars of different sizes (0.5 to 2.5)
            speedX: (Math.random() * 0.2) - 0.1, // Very slow diagonal movement
            speedY: Math.random() * 0.1 + 0.05,  // Slow downward movement
            angle: Math.random() * Math.PI * 2,  // Random starting rotation
            rotationSpeed: 0.01 + (Math.random() * 0.01) // Small rotation speed
        });
    }
}
function updateAndDrawMainScreenStars() {
    if (currentScreen !== "start") {
        // If we're not on the start screen, cancel the animation
        if (mainScreenStarsAnimationId) {
            cancelAnimationFrame(mainScreenStarsAnimationId);
            mainScreenStarsAnimationId = null;
        }
        return;
    }
    
    // Clear the entire canvas with the background color
    ctx.fillStyle = '#10164e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Update and draw stars - make them brighter for better visibility
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; // Increased opacity for visibility
    mainScreenStars.forEach(star => {
        // Update position
        star.x += star.speedX;
        star.y += star.speedY;
        star.angle += star.rotationSpeed;
        
        // Wrap around if off screen
        if (star.x < 0) star.x = canvas.width;
        if (star.x > canvas.width) star.x = 0;
        if (star.y > canvas.height) star.y = 0;
        
        // Draw the star (using the same style as game stars but slightly larger)
        ctx.save();
        ctx.translate(star.x, star.y);
        ctx.rotate(star.angle);
        
        // Draw a simple plus shape - make it larger for better visibility
        const size = star.size * 3; // Increased size
        
        // Horizontal line
        ctx.fillRect(-size, -size/4, size*2, size/2);
        
        // Vertical line
        ctx.fillRect(-size/4, -size, size/2, size*2);
        
        ctx.restore();
    });
    
    // Continue the animation
    mainScreenStarsAnimationId = requestAnimationFrame(updateAndDrawMainScreenStars);
}
function startGame() {
    console.log("Start game function called!");
    
    // Switch to game screen
    switchScreen("game");
    
    // Initialize game - using try/catch for better error handling
    try {
        // Start the background music
        initializeMusic();
        
        // Reset game state
        score = 0;
        gameTime = 0;
        lastTimeCheck = Date.now();
        bossSpawned = false;
        regularEnemiesDisabled = false;
        boss = null;
        explosionAnimation = null;
        
        // Set up game start sequence
        gameStartSequence = true;
        playerReady = false;
        enemySpawningActive = false;
        
        // Initialize device detection and controls
        isMobile = detectMobile();
        
        // Always create mobile controls - They'll only be visible on mobile
        createMobileControls();
        
        // Reset player
        player.y = canvas.height + 100;
        player.hp = player.maxHp;
        player.bullets = [];
        
        // Make player invulnerable until player becomes controllable
        playerInvulnerable = true;
        playerInvulnerableTimer = Date.now();
        
        // Clear enemies
        enemies.length = 0;
        enemyBullets.length = 0;
        circularGroup = null;
        lastGroupSpawn = Date.now();
        
        // Reset powerups
        powerupActive = false;
        powerupBulletsLeft = 0;
        powerup = null;
        powerupSpawned = false;
        reachedMilestones = [false, false, false, false];
        
        // Update UI
        scoreElement.textContent = score;
        hpElement.textContent = player.hp;
        
        // Enable player control and enemy spawning after delay
        setTimeout(() => {
            playerReady = true;
        }, 4000); // 4 seconds
        
        setTimeout(() => {
            enemySpawningActive = true;
        }, 5000); // 5 seconds
        
        // Start the game loop
        gameLoop = requestAnimationFrame(update);
        
        console.log("Game started successfully");
    } catch (e) {
        console.error("Error starting game:", e);
    }
}
function restartGame() {
    isGameRunning = true;
    score = 0;
    gameTime = 0;
    lastTimeCheck = Date.now();
    bossSpawned = false;
    regularEnemiesDisabled = false;
    boss = null;
    explosionAnimation = null; // Make sure this is here
    
    // Reset player position to match initial game start
    player.y = canvas.height + 100; // Start below the screen
    player.x = canvas.width / 2;    // Center horizontally
    player.hp = player.maxHp;
    player.bullets = [];
    
    // Set up game start sequence like in startGame
    gameStartSequence = true;
    playerReady = false;
    enemySpawningActive = false;
    
    // Make player invulnerable for the first 3 seconds
    playerInvulnerable = true;
    playerInvulnerableTimer = Date.now();
    
    enemies.length = 0;
    enemyBullets.length = 0;
    circularGroup = null;
    lastGroupSpawn = Date.now();
    
    // Reset powerups
    powerupActive = false;
    powerupBulletsLeft = 0;
    powerup = null;
    powerupSpawned = false;
    reachedMilestones = [false, false, false, false];

    // Remove any existing powerup indicator
    const indicator = document.getElementById('powerupIndicator');
    if (indicator) {
        indicator.remove();
    }
    
    scoreElement.textContent = score;
    hpElement.textContent = player.hp;
    
    gameOverScreen.style.display = 'none';
    gameStats.style.display = 'block';
    
    // Enable player control and enemy spawning after delay - just like in startGame
    setTimeout(() => {
        playerReady = true;
    }, 4000); // 4 seconds
    
    setTimeout(() => {
        enemySpawningActive = true;
    }, 5000); // 5 seconds
    
    gameLoop = requestAnimationFrame(update);
}
		// Add this function to spawn the boss
		function spawnBoss() {
			bossSpawned = true;
			regularEnemiesDisabled = true;
			lastBossMissile = Date.now();
			bossAnimationFrame = 0;  // Reset animation frame
			bossAnimationTimer = Date.now();  // Reset animation timer
			boss = {
				x: canvas.width / 2,
				y: 100,
				width: 75,
				height: 75,
				hp: 220,
				maxHp: 200,
				lastShot: 0,
				shootingDelay: 1000, // 1 second
				moveDirection: 1,    // 1 for right, -1 for left
				moveSpeed: 1.5,
				movePattern: 0,      // 0 for horizontal, 1 for diagonal
				patternTimer: 0,     // For switching patterns
				patternDuration: 5000 // Switch pattern every 5 seconds
			};
		}

		// Add this function to handle boss shooting
		function bossShooting() {
			if (!boss) return;
			
			const now = Date.now();
			
			// Regular shots
			if (now - boss.lastShot >= boss.shootingDelay) {
				// Three bullets in a spread pattern
				for (let i = -1; i <= 1; i++) {
					enemyBullets.push({
						x: boss.x + (i * 20),
						y: boss.y + boss.height / 2,
						width: 5,
						height: 10,
						speed: 3 + Math.random(),
						angle: Math.PI/2 + (i * Math.PI/12) // Spread pattern
					});
				}
				boss.lastShot = now;
			}
			
			// Missile shots
			if (now - lastBossMissile >= bossMissileDelay) {
				// Create a missile enemy that follows the player
				const missile = {
					x: boss.x,
					y: boss.y + boss.height / 2,
					width: 20,
					height: 30,
					hp: 4,
					speed: 0.7,
					isMissile: true,
					points: 20
				};
				enemies.push(missile);
				lastBossMissile = now;
			}
		}

		// Add this function to update boss movement
		function updateBoss() {
			if (!boss) return;
			
			const now = Date.now();
			
			// Check if it's time to switch patterns
			if (now - boss.patternTimer >= boss.patternDuration) {
				boss.movePattern = (boss.movePattern + 1) % 3; // Toggle between 3 patterns
				boss.patternTimer = now;
			}
			
			// Pattern 0: Horizontal movement
			if (boss.movePattern === 0) {
				boss.x += boss.moveSpeed * boss.moveDirection;
				
				// Bounce at edges
				if (boss.x > canvas.width - boss.width/2 || boss.x < boss.width/2) {
					boss.moveDirection *= -1;
				}
			}
			// Pattern 1: Diagonal movement
			else if (boss.movePattern === 1) {
				boss.x += boss.moveSpeed * boss.moveDirection;
				boss.y += Math.sin(now / 500) * 2; // Wavy up-down movement
				
				// Bounce at edges
				if (boss.x > canvas.width - boss.width/2 || boss.x < boss.width/2) {
					boss.moveDirection *= -1;
				}
				
				// Keep within vertical bounds
				boss.y = Math.max(50, Math.min(canvas.height / 3, boss.y));
			}
			// Pattern 2: "Charge" at player
			else if (boss.movePattern === 2) {
				const targetX = player.x;
				const dx = targetX - boss.x;
				boss.x += (dx * 0.02); // Move 2% of the way to player each frame
				
				// Slow up/down movement during this pattern
				boss.y = 80 + Math.sin(now / 1000) * 30;
			}
			
			// Boss shooting
			bossShooting();
			
			// Check for player collision with boss
			if (checkCollision({
				x: boss.x - boss.width/2,
				y: boss.y - boss.height/2,
				width: boss.width,
				height: boss.height
			}, {
				x: player.x - player.size/2,
				y: player.y - player.size/2,
				width: player.size,
				height: player.size
			})) {
				player.hp -= 20;
				if (player.hp <= 0) {
					endGame();
				}
			}
		}

		// Add this function to draw the boss
		function drawBoss() {
			if (!boss) return;
			
			// Update animation frame
			const now = Date.now();
			if (now - bossAnimationTimer > bossFrameDuration) {
				bossAnimationFrame = (bossAnimationFrame + 1) % bossFrameCount;
				bossAnimationTimer = now;
			}
			
			// Draw boss with animation
			if (window.bossImage.complete) {
				// Calculate the source y position based on current frame
				// For vertical sprite sheet, x stays at 0 but y changes
				const sourceY = bossAnimationFrame * bossFrameHeight;
				
				// Draw the current frame
				ctx.drawImage(
					window.bossImage,
					0, sourceY, bossFrameWidth, bossFrameHeight, // Source rectangle (x, y, width, height)
					boss.x - boss.width/2, boss.y - boss.height/2,   // Destination position
					boss.width, boss.height                         // Destination size
				);
			} else {
				// Fallback if image isn't loaded
				ctx.fillStyle = '#ff0000';
				ctx.beginPath();
				ctx.arc(boss.x, boss.y, boss.width/2, 0, Math.PI * 2);
				ctx.fill();
				
				// Evil eyes
				ctx.fillStyle = 'black';
				ctx.beginPath();
				ctx.arc(boss.x - 15, boss.y - 10, 8, 0, Math.PI * 2);
				ctx.arc(boss.x + 15, boss.y - 10, 8, 0, Math.PI * 2);
				ctx.fill();
				
				// Evil mouth
				ctx.beginPath();
				ctx.arc(boss.x, boss.y + 10, 20, 0, Math.PI);
				ctx.stroke();
			}
			
			// Draw boss HP bar
			const hpBarWidth = boss.width * 1.5;
			const hpBarHeight = 8;
			const hpPercentage = boss.hp / boss.maxHp;
			
			// HP Bar background
			ctx.fillStyle = '#333';
			ctx.fillRect(boss.x - hpBarWidth/2, boss.y - boss.height/2 - 15, hpBarWidth, hpBarHeight);
			
			// HP Bar fill
			ctx.fillStyle = `rgb(${255 * (1 - hpPercentage)}, ${255 * hpPercentage}, 0)`;
			ctx.fillRect(boss.x - hpBarWidth/2, boss.y - boss.height/2 - 15, hpBarWidth * hpPercentage, hpBarHeight);
		}
// Add this function to animate the main character on the start screen
function animateMainCharacter() {
    if (currentScreen !== "start") return;
    
    const animCanvas = document.getElementById('characterAnimCanvas');
    if (!animCanvas) return;
    
    const animCtx = animCanvas.getContext('2d');
    
    // Update animation frame
    const now = Date.now();
    if (now - mainCharacterAnimTimer > mainCharacterFrameDuration) {
        mainCharacterAnimFrame = (mainCharacterAnimFrame + 1) % mainCharacterFrameCount;
        mainCharacterAnimTimer = now;
    }
    
    // Clear the canvas - don't clear it here as we're using the stars as background
    animCtx.clearRect(0, 0, animCanvas.width, animCanvas.height);
    
    // Draw the current frame if image is loaded
    if (window.mainCharacterAnimImage.complete) {
        // Draw the current frame from the sprite sheet
        animCtx.drawImage(
            window.mainCharacterAnimImage,
            0, mainCharacterAnimFrame * (mainCharacterFrameHeight / mainCharacterFrameCount), 
            mainCharacterFrameWidth, mainCharacterFrameHeight / mainCharacterFrameCount,
            0, 0,
            animCanvas.width, animCanvas.height
        );
    }
    
    // Continue animation
    requestAnimationFrame(animateMainCharacter);
}
        function endGame() {
            isGameRunning = false;
            cancelAnimationFrame(gameLoop);
            finalScoreElement.textContent = score;
            gameStats.style.display = 'none';
            gameOverScreen.style.display = 'block';
        }
        function spawnCircularGroup() {
            const groupCenterX = canvas.width / 2;
            const groupCenterY = -140;
            const radius = 140;
            
            circularGroup = {
                centerX: groupCenterX,
                centerY: groupCenterY,
                radius: radius,
                angle: 0,
                rotationSpeed: 0.005,
                moveSpeed: 0.3,
                members: []
            };
            // Spawn 10 enemies in a circle
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI * 2) / 6;
                const enemy = {
                    baseAngle: angle,
                    x: groupCenterX + Math.cos(angle) * radius,
                    y: groupCenterY + Math.sin(angle) * radius,
                    width: 22,
                    height: 22,
                    hp: 2,
                    points: 15,
                    isCircular: true
                };
                circularGroup.members.push(enemy);
                enemies.push(enemy);
            }
        }
        function updateCircularGroup() {
            if (!circularGroup) return;
            // Update group position
            circularGroup.centerY += circularGroup.moveSpeed;
            circularGroup.angle += circularGroup.rotationSpeed;
            // Update each member's position
            circularGroup.members.forEach((enemy, index) => {
                const angle = enemy.baseAngle + circularGroup.angle;
                enemy.x = circularGroup.centerX + Math.cos(angle) * circularGroup.radius;
                enemy.y = circularGroup.centerY + Math.sin(angle) * circularGroup.radius;
            });
            // Remove group if it's off screen
            if (circularGroup.centerY > canvas.height + circularGroup.radius * 2) {
                circularGroup.members.forEach(member => {
                    const index = enemies.indexOf(member);
                    if (index > -1) {
                        enemies.splice(index, 1);
                    }
                });
                circularGroup = null;
            }
            // Or if all members are destroyed
            else if (circularGroup.members.every(m => !enemies.includes(m))) {
                circularGroup = null;
            }
        }
        function spawnEnemy() {
			// Check if it's time to spawn a circular group
			const now = Date.now();
			if (!circularGroup && now - lastGroupSpawn >= groupSpawnDelay && gameTime >= 36) {
				spawnCircularGroup();
				lastGroupSpawn = now;
				return;
			}
			
			// Check if game time is past 10 seconds for shooting enemies
			const canSpawnShootingEnemy = gameTime >= 10;
			
			// Regular enemy spawn logic - only allow shooting enemies after 10 seconds
			const isShootingEnemy = canSpawnShootingEnemy && Math.random() < 0.3;
			
			const enemy = {
				x: Math.random() * (canvas.width - 20),
				y: -20,
				width: 22,
				height: 22,
				speed: isShootingEnemy ? 0.8 : 1.1,
				hp: isShootingEnemy ? 2 : 2,
				points: isShootingEnemy ? 20 : 10,
				isShooting: isShootingEnemy,
				lastShot: 0,
				shootingDelay: 2000,
				// Add rotation properties
				angle: 0,
				rotationSpeed: (Math.random() * 0.05) + 0.01, // Small random rotation speed
				hitboxScale: 1.5 // Make hitbox 1.5x larger than visual
			};
			enemies.push(enemy);
		}
		// Add this function to spawn the powerup
function spawnPowerup() {
    powerup = {
        x: Math.random() * (canvas.width - 30) + 15, // Keep away from edges
        y: -20,
        width: 40,
        height: 40,
        speed: 0.8
    };
    powerupSpawned = true;
}

// Add this function to update the powerup position and check for collision
function updatePowerup() {
    if (!powerup) return;
    
    powerup.y += powerup.speed;
    
    // Check if player collected the powerup
    if (checkCollision(powerup, {
        x: player.x - player.size/2,
        y: player.y - player.size/2,
        width: player.size,
        height: player.size
    })) {
        powerupActive = true;
        powerupBulletsLeft = 300;
        powerup = null;
        
    }
    
    // Remove if offscreen
    if (powerup && powerup.y > canvas.height) {
        powerup = null;
    }
}

	// Add this function to draw the powerup
function drawPowerup() {
    if (!powerup) return;
    
    ctx.drawImage(window.powerupImage, 
        powerup.x - powerup.width/2, 
        powerup.y - powerup.height/2,
        powerup.width,
        powerup.height
    );
}

	// Modify the shoot function to handle rapid fire
	function shoot() {
		const now = Date.now();
		const currentShootingDelay = powerupActive ? rapidFireShootingDelay : shootingDelay;
		
		if (now - lastShot >= currentShootingDelay) {
			player.bullets.push({
				x: player.x,
				y: player.y,
				width: 3,
				height: 8,
				speed: 7
			});
			lastShot = now;
			
			// Track powerup bullets
			if (powerupActive) {
				powerupBulletsLeft--;
				
				
				// End powerup if bullets are used up
				if (powerupBulletsLeft <= 0) {
					powerupActive = false;
					
				}
			}
		}
	}

        function enemyShoot(enemy) {
            const now = Date.now();
            if (now - enemy.lastShot >= enemy.shootingDelay) {
                enemyBullets.push({
                    x: enemy.x + enemy.width / 2,
                    y: enemy.y + enemy.height,
                    width: 3,
                    height: 8,
                    speed: 2.5
                });
                enemy.lastShot = now;
            }
        }
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
function updateBullets() {
    for (let i = player.bullets.length - 1; i >= 0; i--) {
        const bullet = player.bullets[i];
        bullet.y -= bullet.speed;
        
        if (bullet.y < 0) {
            player.bullets.splice(i, 1);
            continue;
        }
        
        // Check for boss hit
        if (boss && checkCollision(bullet, {
            x: boss.x - boss.width/2,
            y: boss.y - boss.height/2,
            width: boss.width,
            height: boss.height
        })) {
            boss.hp--;
            player.bullets.splice(i, 1);
            
            // Boss death
            if (boss.hp <= 0) {
                // Start explosion animation instead of instant damage
                explosionAnimation = {
                    centerX: boss.x,
                    centerY: boss.y,
                    radius: 10,
                    startTime: Date.now(),
                    duration: 5000, // 5 seconds
                    completed: false
                };
                
                boss = null;
                score += 1000; // Big points for defeating boss
                continue;
            }
            continue;
        }
        
        // Regular enemy hit check
        // Regular enemy hit check
		for (let j = enemies.length - 1; j >= 0; j--) {
			const enemy = enemies[j];
			
			// Apply larger hitbox for enemy collision
			let hitboxWidth = enemy.width;
			let hitboxHeight = enemy.height;
			
			// Apply larger hitbox for non-spinner enemies
			if (!enemy.isSpinner && !enemy.isMissile) {
				hitboxWidth *= enemy.hitboxScale || 1.5;
				hitboxHeight *= enemy.hitboxScale || 1.5;
			}
			
			if (checkCollision(bullet, {
				x: enemy.x - hitboxWidth/2,
				y: enemy.y - hitboxHeight/2,
				width: hitboxWidth,
				height: hitboxHeight
			})) {
				enemy.hp--;
				player.bullets.splice(i, 1);
				
				if (enemy.hp <= 0) {
					score += enemy.points;
					scoreElement.textContent = score;
					enemies.splice(j, 1);
					if (circularGroup) {
						circularGroup.members = circularGroup.members.filter(m => m !== enemy);
					}
				}
				break;
			}
		}
    }
}
function updateEnemyBullets() {
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const bullet = enemyBullets[i];
        bullet.y += bullet.speed;
        
        if (bullet.y > canvas.height) {
            enemyBullets.splice(i, 1);
            continue;
        }
        
        // Check player collision with bullet
        if (!playerInvulnerable && checkCollision(bullet, {
			x: player.x - player.size/2,
			y: player.y - player.size/2,
			width: player.size,
			height: player.size
		})) {
            player.hp -= 5; // Bullet damage
            hpElement.textContent = player.hp;
            enemyBullets.splice(i, 1);
            
            if (player.hp <= 0) {
                endGame();
            }
        }
    }
}
 
		function updateExplosion() {
    if (!explosionAnimation) return;
    
    const now = Date.now();
    const elapsed = now - explosionAnimation.startTime;
    const progress = Math.min(elapsed / explosionAnimation.duration, 1);
	
	// If animation is complete, don't render anything else
    if (progress >= 1) {
        if (!explosionAnimation.completed) {
            explosionAnimation.completed = true;
            
            // Defeat player when animation completes
            player.hp -= 100;
            hpElement.textContent = player.hp;
            if (player.hp <= 0) {
                endGame();
            }
        }
        // Don't continue with rendering if animation is done
        return;
    }
    
    // Calculate expanding radius - make it larger to ensure it covers the whole screen
    const maxRadius = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height) * 1.5;
    explosionAnimation.radius = progress * maxRadius;
    
    // Create a brighter, more intense explosion
    // Start with pure white, then add a yellow/orange glow at the end
    const brightness = 1 - (progress * 0.3); // Stays brighter longer
    
    // Create a pulsing effect for added intensity
    const pulse = Math.sin(progress * 10) * 0.1 * (1 - progress) + 1;
	
    // Draw the explosion in a layer above everything else
    // First draw a bright white center that covers the entire screen
    ctx.fillStyle = `rgba(255, 255, 255, ${brightness * pulse})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height); // Cover the entire screen	
    
    // Then draw the expanding circle with a glow
    const gradient = ctx.createRadialGradient(
        explosionAnimation.centerX, explosionAnimation.centerY, 0,
        explosionAnimation.centerX, explosionAnimation.centerY, explosionAnimation.radius
    );
    
    gradient.addColorStop(0, `rgba(255, 255, 255, ${brightness * 0.9})`);
    gradient.addColorStop(0.6, `rgba(255, 255, 200, ${brightness * 0.7})`);
    gradient.addColorStop(0.8, `rgba(255, 170, 100, ${brightness * 0.5})`);
    gradient.addColorStop(1, `rgba(255, 100, 50, ${brightness * 0.3})`);
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(explosionAnimation.centerX, explosionAnimation.centerY, 
            explosionAnimation.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Add visual feedback - random smaller "sparkles" for dramatic effect
    if (progress < 0.8) {
        for (let i = 0; i < 5; i++) {
            const sparkX = explosionAnimation.centerX + (Math.random() - 0.5) * explosionAnimation.radius * progress;
            const sparkY = explosionAnimation.centerY + (Math.random() - 0.5) * explosionAnimation.radius * progress;
            const sparkSize = 20 + Math.random() * 50;
            
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.beginPath();
            ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    // Check if animation is complete
    if (elapsed >= explosionAnimation.duration && !explosionAnimation.completed) {
        explosionAnimation.completed = true;
        
        // Defeat player when animation completes
        player.hp -= 100;
        if (player.hp <= 0) {
            endGame();
        }
    }
}
        function updateEnemies() {
			// Only spawn regular enemies if boss isn't active, not disabled, and enemy spawning is active
			if (enemySpawningActive && !regularEnemiesDisabled && enemies.length < 5 && Math.random() < 0.02) {
				// Check if game time is past 1 minute (60 seconds) and add chance for spinner
				if (gameTime >= 60 && Math.random() < 0.2) { // 20% chance to spawn spinner instead of regular enemy
					// Spawn spinner enemy
					const spinnerEnemy = {
						x: Math.random() * (canvas.width - 30) + 15,
						y: 60, // Slightly below the top
						width: 24,
						height: 24,
						hp: 8, // Tougher than regular enemies
						speed: 4, // Fast when launched
						points: 50, // Worth more points
						isSpinner: true,
						spinTimer: Date.now(),
						spinDuration: 3000, // 3 seconds of spinning
						angle: 0, // Current rotation angle
						launched: false
					};
					enemies.push(spinnerEnemy);
				} else {
					spawnEnemy();
				}
			}
			
			updateCircularGroup();
			
			for (let i = enemies.length - 1; i >= 0; i--) {
				const enemy = enemies[i];
				
				if (!enemy.isSpinner) { // Don't modify spinner enemies since they have their own rotation
					enemy.angle += enemy.rotationSpeed;
				}
				
				if (enemy.isSpinner) {
					// Increase rotation angle
					enemy.angle += 0.1; // Rotation speed
					
					// Check if it's time to launch
					const now = Date.now();
					if (!enemy.launched && now - enemy.spinTimer >= enemy.spinDuration) {
						enemy.launched = true;
						
						// Calculate direction to player
						const dx = player.x - enemy.x;
						const dy = player.y - enemy.y;
						const distance = Math.sqrt(dx * dx + dy * dy);
						
						// Store normalized direction
						if (distance > 0) {
							enemy.dirX = dx / distance;
							enemy.dirY = dy / distance;
						} else {
							enemy.dirX = 0;
							enemy.dirY = 1; // Default downward
						}
					}
					
					// Move if launched
					if (enemy.launched) {
						enemy.x += enemy.dirX * enemy.speed;
						enemy.y += enemy.dirY * enemy.speed;
					}
				}
				else if (enemy.isMissile) {
					// Calculate direction to player for homing
					const dx = player.x - enemy.x;
					const dy = player.y - enemy.y;
					const distance = Math.sqrt(dx * dx + dy * dy);
					
					// Update position
					if (distance > 0) {
						enemy.x += (dx / distance) * enemy.speed;
						enemy.y += (dy / distance) * enemy.speed;
					} else {
						enemy.y += enemy.speed;
					}
				}
				// Handle regular and shooting enemies
				else if (!enemy.isCircular) {
					enemy.y += enemy.speed;
					
					// Make shooting enemies shoot
					if (enemy.isShooting) {
						enemyShoot(enemy);
					}
				}
				
				// Check for collision with player for all enemy types
				if (!playerInvulnerable && checkCollision(enemy, {
					x: player.x - player.size/2,
					y: player.y - player.size/2,
					width: player.size,
					height: player.size
				})) {
					// Different damage based on enemy type HUOMIO
							
					if (enemy.isSpinner && enemy.launched) {
						player.hp -= 30; // Spinner deals 30 damage when launched
					} else if (enemy.isMissile) {
						player.hp -= 15; // Missiles deal 15 damage
					} else {
						player.hp -= 10; // Regular enemies deal 10 damage
					}
					
					enemies.splice(i, 1);
					if (circularGroup) {
						circularGroup.members = circularGroup.members.filter(m => m !== enemy);
					}
					if (player.hp <= 0) {
						endGame();
					}
					continue;
				}
				
				// Check if enemy is off-screen
				if ((!enemy.isCircular && !enemy.isMissile && !enemy.isSpinner && enemy.y > canvas.height + enemy.height) ||
					(enemy.isSpinner && enemy.launched && (enemy.x < -50 || enemy.x > canvas.width + 50 || enemy.y < -50 || enemy.y > canvas.height + 50))) {
					enemies.splice(i, 1);
					if (circularGroup) {
						circularGroup.members = circularGroup.members.filter(m => m !== enemy);
					}
				}
			}
		}

function drawEnemies() {
    enemies.forEach(enemy => {
        if (enemy.isSpinner) {
            // Save context for rotation
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate(enemy.angle);
            
            // Draw the spinner with the image
            const size = enemy.width * 2.2; // Adjust size as needed
            
            // Draw the spinning star image
            ctx.drawImage(window.spinnerEnemyImage, 
                -size/2, -size/2,
                size, size);
            
            // If not launched yet, add a pulsing effect
            if (!enemy.launched) {
                // Pulsing overlay while charging
                const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.4;
                ctx.fillStyle = `rgba(255, 255, 0, ${pulse})`;
                ctx.globalCompositeOperation = 'overlay';
                ctx.beginPath();
                ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Restore context
            ctx.restore();
        }
        else if (enemy.isMissile) {
            // Draw missile...
			ctx.fillStyle = '#FF3300';
            ctx.beginPath();
            // Missile body
            ctx.moveTo(enemy.x, enemy.y - enemy.height/2);
            ctx.lineTo(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
            ctx.lineTo(enemy.x - enemy.width/2, enemy.y + enemy.height/2);
            ctx.closePath();
            ctx.fill();
            
            // Fire trail
            ctx.fillStyle = 'orange';
            ctx.beginPath();
            ctx.moveTo(enemy.x - enemy.width/4, enemy.y + enemy.height/2);
            ctx.lineTo(enemy.x, enemy.y + enemy.height);
            ctx.lineTo(enemy.x + enemy.width/4, enemy.y + enemy.height/2);
            ctx.closePath();
            ctx.fill();
        } 
        else if (enemy.isCircular) {
            // Apply rotation for circular enemies
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate(enemy.angle);
            ctx.drawImage(window.circularEnemyImage,           
                -enemy.width,
                -enemy.height,
                enemy.width * 2,
                enemy.height * 2
            );
            ctx.restore();
        } 
        else if (enemy.isShooting) {
            // Apply rotation for shooting enemies
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate(enemy.angle);
            ctx.drawImage(window.shootingEnemyImage,
                -enemy.width,
                -enemy.height,
                enemy.width * 2,
                enemy.height * 2
            );
            ctx.restore();
        } 
        else {
            // Apply rotation for regular enemies
            ctx.save();
            ctx.translate(enemy.x, enemy.y);
            ctx.rotate(enemy.angle);
            ctx.drawImage(window.enemyImage, 
                -enemy.width,
                -enemy.height,
                enemy.width * 2,
                enemy.height * 2
            );
            ctx.restore();
        }
    });
}

function drawBullets() {
    ctx.fillStyle = '#4CAF50'; // Always use green (#4CAF50) for player bullets
    player.bullets.forEach(bullet => {
        ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width * 1.5, bullet.height * 1.5);
    });
}

function drawEnemyBullets() {
    ctx.fillStyle = '#FF6B6B';
    enemyBullets.forEach(bullet => {
        ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
    });
}
// Replace your current update function with this corrected version:
function update() {
    // Make sure we don't run the game loop while loading
    if (isLoading) {
        requestAnimationFrame(update);
        return;
    }

    // If the game is not running, we shouldn't be in this function
    if (!isGameRunning) {
        // Clear the canvas with black to ensure no remnants of loading screen
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        return;
    }
    
    // Track game time
    const now = Date.now();
    const deltaTime = now - lastTimeCheck;
    lastTimeCheck = now;
    gameTime += deltaTime / 1000; // Convert to seconds
    
    // Check for boss spawn at 3:30 (210 seconds)
    if (gameTime >= 189 && !bossSpawned) {
		// Stop enemy spawning 9 seconds before boss appears
		regularEnemiesDisabled = true;
	}

	if (gameTime >= 180 && !bossSpawned) {
		// Clear all existing enemies
		enemies.length = 0;
		enemyBullets.length = 0;
		circularGroup = null;
		
		// Spawn boss
		spawnBoss();
	}
    
    // Check for powerup milestones
    for (let i = 0; i < powerupMilestones.length; i++) {
        if (score >= powerupMilestones[i] && !reachedMilestones[i] && !powerup && !powerupActive) {
            spawnPowerup();
            reachedMilestones[i] = true;
            break; // Only spawn one powerup at a time
        }
    }

    // Update powerup position and check for collection
    updatePowerup();
    
    // Stop spawning regular enemies at 3:20 (200 seconds)
    if (gameTime >= 200) {
        regularEnemiesDisabled = true;
    }
    
    // Clear screen
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Add enhanced UI elements - using canvas drawing for consistent display across all devices
	// Update the update() function, around line 2090 where the UI elements are drawn
	// Replace the UI drawing code with this:

	// Add enhanced UI elements - using canvas drawing for consistent display across all devices
	ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
	const statusBarHeight = Math.max(40, canvas.height * 0.06); // Min 40px or 6% of height
	ctx.fillRect(0, 0, canvas.width, statusBarHeight); // Top bar for stats

	// Make score more prominent
	ctx.fillStyle = '#4CAF50';
	ctx.font = `bold ${Math.max(14, statusBarHeight * 0.45)}px Arial`; // Scale font size
	ctx.textAlign = 'left';
	ctx.fillText(`Score: ${score}`, 10, statusBarHeight * 0.65);

	// Display Powerup status if active
	if (powerupActive) {
		ctx.fillStyle = 'yellow';
		ctx.font = `bold ${Math.max(14, statusBarHeight * 0.45)}px Arial`;
		ctx.textAlign = 'center';
		ctx.fillText(`Rapid Fire: ${powerupBulletsLeft}`, canvas.width / 2, statusBarHeight * 0.65);
	}

	// Display HP as a bar - Scale to screen width for responsive design
	const hpBarWidth = Math.min(canvas.width * 0.3, 120); // Responsive width, max 120px
	const hpBarHeight = statusBarHeight * 0.4;
	const hpPercent = player.hp / player.maxHp;

	// HP Bar background
	ctx.fillStyle = '#333';
	ctx.fillRect(canvas.width - hpBarWidth - 10, statusBarHeight * 0.3, hpBarWidth, hpBarHeight);

	// HP Bar fill with color based on percentage
	ctx.fillStyle = hpPercent > 0.6 ? '#4CAF50' : hpPercent > 0.3 ? '#FFC107' : '#F44336';
	ctx.fillRect(canvas.width - hpBarWidth - 10, statusBarHeight * 0.3, hpBarWidth * hpPercent, hpBarHeight);

	// Add separators for UI sections
	ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
	ctx.fillRect(canvas.width / 3, 5, 1, 30);
	ctx.fillRect(canvas.width * 2 / 3, 5, 1, 30);
    
    // Update and draw background first
    updateStars();
    
    // Update and draw boss if it exists
    if (boss) {
        updateBoss();
        drawBoss();
    }

    drawStars();
    
    // Player movement and control
    if (gameStartSequence && !playerReady) {
        // Smoothly bring player up from bottom of screen
        player.y -= 0.5;
        player.x = canvas.width / 2; // Keep centered during intro
        
        // Check if player reached target position
        if (player.y <= canvas.height - 100) {
            player.y = canvas.height - 100;
            // Leave gameStartSequence true until timer completes
        }
    } else if (playerReady) {
        if (isMobile) {
            // Mobile joystick controls
            if (joystick.active) {
                // Calculate direction vector
                const dx = joystick.knobX - joystick.baseX;
                const dy = joystick.knobY - joystick.baseY;
				
				// Calculate length of movement from center
				const length = Math.sqrt(dx * dx + dy * dy);
				
				// Add a dead zone in the center (no movement if joystick is barely moved)
				const deadZone = joystick.maxDistance * 0.15; // 15% of max distance is dead zone
				
				if (length > deadZone) { // Only move if outside dead zone
					// Calculate how far the joystick is moved as a percentage of max distance
					// Subtract the deadZone and normalize to the remaining distance
					const normalizedLength = (length - deadZone) / (joystick.maxDistance - deadZone);
					
					// Calculate the movement speed based on how far joystick is moved
					// This creates a curve where slight movements cause slow speed,
					// and full movements cause full speed
					const maxSpeed = 3;
					const moveSpeed = maxSpeed * normalizedLength; // Define moveSpeed based on normalization
					// Apply movement in the joystick direction
					player.x += (dx / length) * moveSpeed;
					player.y += (dy / length) * moveSpeed;
				}
                
                
            }
            
            // Fire button controls
            if (fireButton.pressed) {
                shoot();
            }
        } else {
            // Desktop keyboard controls
            const moveSpeed = 2.5;
            
            if (keys['ArrowLeft']) player.x -= moveSpeed;
            if (keys['ArrowRight']) player.x += moveSpeed;
            if (keys['ArrowUp']) player.y -= moveSpeed;
            if (keys['ArrowDown']) player.y += moveSpeed;
            
            // Spacebar shooting
            if (keys['Space']) {
                shoot();
            }
        }
        
        
        // Keep player within bounds
        player.x = Math.max(player.size/2, Math.min(canvas.width - player.size/2, player.x));
		player.y = Math.max(player.size/2, Math.min(canvas.height - player.size/2, player.y));
		} else {
			// Always allow mouse movement control when player is ready
			if (playerReady && !isMobile) {
				player.x = Math.max(player.size/2, Math.min(canvas.width - player.size/2, mouseX));
				player.y = Math.max(canvas.height/3, Math.min(canvas.height - player.size/2, mouseY));
			}
		}

    // Check invulnerability timer
	if (playerInvulnerable) {
		// Only remove invulnerability if player is ready
		if (playerReady && Date.now() - playerInvulnerableTimer >= 3000) { // 3 seconds after player is ready
			playerInvulnerable = false;
		}
	}
    
    // Update game elements
    updateBullets();
    updateEnemyBullets();
    updateEnemies();
    
    // Draw game elements
    drawBullets();
    drawEnemyBullets();
    drawPowerup(); // Draw powerup if it exists
    drawEnemies();
    
    // Draw player
    ctx.drawImage(window.playerImage, 
        player.x - player.size/2, 
        player.y - player.size/2,
        player.size,
        player.size
    );
    
    // Draw invulnerability effect
    if (playerInvulnerable) {
        ctx.strokeStyle = 'rgba(0, 255, 255, ' + (0.7 + Math.sin(Date.now() / 100) * 0.3) + ')';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.size/2 + 5, 0, Math.PI * 2);
        ctx.stroke();
    }
    

    
    // Draw mobile controls if on mobile
    if (isMobile) {
        // Draw joystick base
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(joystick.baseX, joystick.baseY, joystick.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw joystick knob
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = '#4CAF50';
        ctx.beginPath();
        ctx.arc(joystick.knobX, joystick.knobY, joystick.knobRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw fire button
        ctx.globalAlpha = fireButton.pressed ? 0.7 : 0.3;
        ctx.fillStyle = '#FF4444';
        ctx.beginPath();
        ctx.arc(fireButton.x, fireButton.y, fireButton.radius, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw fire icon in button
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.moveTo(fireButton.x - 15, fireButton.y);
        ctx.lineTo(fireButton.x + 15, fireButton.y);
        ctx.lineTo(fireButton.x, fireButton.y - 20);
        ctx.closePath();
        ctx.fill();
        
        ctx.globalAlpha = 1.0; // Reset alpha
    }
    
    // Update explosion animation
    if (explosionAnimation) {
        updateExplosion();
    }
    
    gameLoop = requestAnimationFrame(update);
}
// Add this function outside of any other function
// Modify the drawMobileControls function
function drawMobileControls() {
    if (!isMobile || !playerReady) return;
    
    // Draw joystick base with improved visibility
    ctx.globalAlpha = 0.5; // Increased from 0.3 for better visibility
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.arc(joystick.baseX, joystick.baseY, joystick.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Add a visible border
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Draw joystick knob
    ctx.globalAlpha = 0.7; // Increased from 0.5
    ctx.fillStyle = '#4CAF50';
    ctx.beginPath();
    ctx.arc(joystick.knobX, joystick.knobY, joystick.knobRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw fire button with improved visibility
    ctx.globalAlpha = fireButton.pressed ? 0.8 : 0.6; // Increased for better visibility
    ctx.fillStyle = '#FF4444';
    ctx.beginPath();
    ctx.arc(fireButton.x, fireButton.y, fireButton.radius, 0, Math.PI * 2);
    ctx.fill();
    
    // Add a visible border for fire button
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Draw fire icon in button
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.moveTo(fireButton.x - 15, fireButton.y);
    ctx.lineTo(fireButton.x + 15, fireButton.y);
    ctx.lineTo(fireButton.x, fireButton.y - 20);
    ctx.closePath();
    ctx.fill();
    
    ctx.globalAlpha = 1.0; // Reset alpha
}

// Add this function outside of any other function
function updatePlayerMovement() {
    if (gameStartSequence && !playerReady) {
        // Intro animation - same as before
        player.y = canvas.height + 100;
        player.x = canvas.width / 2;
        
        if (player.y <= canvas.height - 100) {
            player.y = canvas.height - 100;
        }
    } else if (playerReady) {
        if (isMobile) {
            // Mobile joystick controls
            if (joystick.active) {
                // Calculate direction vector
                const dx = joystick.knobX - joystick.baseX;
                const dy = joystick.knobY - joystick.baseY;
                
                // Normalize the vector and apply to player position
                const length = Math.sqrt(dx * dx + dy * dy);
                if (length > 0) {
                    const moveSpeed = 3; // Adjust as needed
                    player.x += (dx / length) * moveSpeed;
                    player.y += (dy / length) * moveSpeed;
                }
            }
            
            // Fire button controls
            if (fireButton.pressed) {
                shoot();
            }
        } else {
            // Desktop keyboard controls
            const moveSpeed = 0.4;
            
            if (keys['ArrowLeft']) player.x -= moveSpeed;
            if (keys['ArrowRight']) player.x += moveSpeed;
            if (keys['ArrowUp']) player.y -= moveSpeed;
            if (keys['ArrowDown']) player.y += moveSpeed;
            
            // Spacebar shooting
            if (keys['Space']) {
                shoot();
            }
        }
        
        // Keep player within bounds (for both control methods)
        player.x = Math.max(player.size/2, Math.min(canvas.width - player.size/2, player.x));
		player.y = Math.max(player.size/2, Math.min(canvas.height - player.size/2, player.y));
    }
}
        // Event listeners
		canvas.addEventListener('mousemove', (e) => {
			const rect = canvas.getBoundingClientRect();
			mouseX = e.clientX - rect.left;
			mouseY = e.clientY - rect.top;
		});
        canvas.addEventListener('mousedown', () => {
            isMouseDown = true;
        });
        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });
        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
		//iOS
		canvas.addEventListener('gesturestart', function(e) {
			e.preventDefault();
		});
		// Add touch support
		canvas.addEventListener('touchstart', (e) => {
			e.preventDefault();
			
			if (!playerReady) return;
			
			const rect = canvas.getBoundingClientRect();
			
			for (let i = 0; i < e.touches.length; i++) {
				const touch = e.touches[i];
				const touchX = touch.clientX - rect.left;
				const touchY = touch.clientY - rect.top;
				
				// Normalize touchX and touchY to the canvas scale
				const normalizedX = touchX * (canvas.width / rect.width);
				const normalizedY = touchY * (canvas.height / rect.height);
				
				// Only process joystick touches on the LEFT HALF of the screen
				if (normalizedX < canvas.width / 2) {
					// Check if the touch is on the joystick
					const joystickDistance = Math.sqrt(
						Math.pow(normalizedX - joystick.baseX, 2) + 
						Math.pow(normalizedY - joystick.baseY, 2)
					);
					
					if (joystickDistance <= joystick.radius) {
						joystick.active = true;
						joystick.knobX = normalizedX;
						joystick.knobY = normalizedY;
					}
				}
				// Only process fire button touches on the RIGHT HALF of the screen
				else {
					// Check if the touch is on the fire button
					const fireButtonDistance = Math.sqrt(
						Math.pow(normalizedX - fireButton.x, 2) + 
						Math.pow(normalizedY - fireButton.y, 2)
					);
					
					if (fireButtonDistance <= fireButton.radius) {
						fireButton.pressed = true;
					}
				}
			}
		}, { passive: false });


		canvas.addEventListener('touchmove', (e) => {
			e.preventDefault();
			
			if (!playerReady) return;
			
			const rect = canvas.getBoundingClientRect();
			
			for (let i = 0; i < e.touches.length; i++) {
				const touch = e.touches[i];
				const touchX = touch.clientX - rect.left;
				const touchY = touch.clientY - rect.top;
				
				// Normalize touchX and touchY to the canvas scale
				const normalizedX = touchX * (canvas.width / rect.width);
				const normalizedY = touchY * (canvas.height / rect.height);
				
				// Only update joystick for touches on the LEFT side
				if (normalizedX < canvas.width / 2) {
					// Only update if joystick is active
					if (joystick.active) {
						const joystickDistance = Math.sqrt(
							Math.pow(normalizedX - joystick.baseX, 2) + 
							Math.pow(normalizedY - joystick.baseY, 2)
						);
						
						if (joystickDistance <= joystick.maxDistance) {
							joystick.knobX = normalizedX;
							joystick.knobY = normalizedY;
						} else {
							// Limit the knob to the maximum distance
							const angle = Math.atan2(normalizedY - joystick.baseY, normalizedX - joystick.baseX);
							joystick.knobX = joystick.baseX + Math.cos(angle) * joystick.maxDistance;
							joystick.knobY = joystick.baseY + Math.sin(angle) * joystick.maxDistance;
						}
					}
				}
				// Only update fire button for touches on the RIGHT side
				else {
					// Check if the touch is on or near the fire button
					const fireButtonDistance = Math.sqrt(
						Math.pow(normalizedX - fireButton.x, 2) + 
						Math.pow(normalizedY - fireButton.y, 2)
					);
					
					// Update fire button state based on whether the touch is on it
					if (fireButtonDistance <= fireButton.radius) {
						fireButton.pressed = true;
					}
				}
			}
		}, { passive: false });

			// Update touchend handler to better track active touches
			canvas.addEventListener('touchend', (e) => {
				// Check remaining touches to see if any are still on our controls
				const rect = canvas.getBoundingClientRect();
				let joystickStillActive = false;
				let fireButtonStillPressed = false;
				
				// Loop through all ACTIVE touches to see if any are still on our controls
				for (let i = 0; i < e.touches.length; i++) {
					const touch = e.touches[i];
					const touchX = touch.clientX - rect.left;
					const touchY = touch.clientY - rect.top;
					
					// Normalize touchX and touchY to the canvas scale
					const normalizedX = touchX * (canvas.width / rect.width);
					const normalizedY = touchY * (canvas.height / rect.height);
					
					// Left side - joystick
					if (normalizedX < canvas.width / 2) {
						joystickStillActive = true;
					}
					// Right side - fire button
					else {
						const fireButtonDistance = Math.sqrt(
							Math.pow(normalizedX - fireButton.x, 2) + 
							Math.pow(normalizedY - fireButton.y, 2)
						);
						
						if (fireButtonDistance <= fireButton.radius) {
							fireButtonStillPressed = true;
						}
					}
				}
				
				// Reset controls if no touches remain on them
				if (!joystickStillActive) {
					joystick.active = false;
					joystick.knobX = joystick.baseX;
					joystick.knobY = joystick.baseY;
				}
				
				if (!fireButtonStillPressed) {
					fireButton.pressed = false;
				}
			});
        // Initial render

        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
if (document.readyState === "complete" || document.readyState === "interactive") {
    setTimeout(function() {
        console.log("Document already loaded, initializing manually");
        // Initialize images if they don't exist
        window.enemyImage = window.enemyImage || new Image();
        window.shootingEnemyImage = window.shootingEnemyImage || new Image();
        window.circularEnemyImage = window.circularEnemyImage || new Image();
        window.spinnerEnemyImage = window.spinnerEnemyImage || new Image();
        window.powerupImage = window.powerupImage || new Image();
        window.bossImage = window.bossImage || new Image();
        window.playerImage = window.playerImage || new Image();
        window.logoImage = window.logoImage || new Image();
        
        if (typeof startLoading === "function") {
            startLoading();
        } else {
            console.error("startLoading function not found");
        }
    }, 200);
}
    </script>
	<script>
        // Debug helper - fires when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM is now loaded - Elements check:");
            console.log("- Canvas:", document.getElementById('gameCanvas'));
            console.log("- Start Screen:", document.getElementById('startScreen'));
            console.log("- Start Button:", document.getElementById('startButton'));
            console.log("- Game Stats:", document.getElementById('gameStats'));
            console.log("- Game Over Screen:", document.getElementById('gameOverScreen'));
            
            // Add visible debug info
			/*
            setTimeout(function() {
                if (!isGameRunning) {
                    // Add emergency start button if game isn't running
                    var emergencyBtn = document.createElement('button');
                    emergencyBtn.textContent = "Emergency Start";
                    emergencyBtn.style = "position:fixed; top:10px; right:10px; z-index:9999; background:red; color:white; padding:10px;";
                    emergencyBtn.onclick = function() {
                        startGame();
                    };
                    document.body.appendChild(emergencyBtn);
                    
                    console.log("Added emergency start button");
                }
            }, 5000);
			*/
        });
    </script>
</body>
</html>
